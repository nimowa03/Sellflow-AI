{
  "rules": [
    {
      "type": "prd",
      "content": "## 1. 프로젝트 개요\n\n### 1.1. 프로젝트 목표\n\nAI 에이전트를 활용하여 상품 기획, 등록, 판매, 고객 관리까지 모든 과정을 자동화하여 1인 셀러가 '브랜딩'에만 집중할 수 있도록 지원하는 SaaS 플랫폼 개발\n\n### 1.2. 주요 기능\n\n*   **상품 기획 에이전트**: 트렌드 분석, 경쟁사 분석 등을 통해 상품 아이디어를 제안\n*   **콘텐츠 생성 에이전트**: 이미지, 상세 페이지, 마케팅 문구 등을 자동으로 생성\n*   **법률 자문 에이전트**: 법적 리스크를 검사하고, 안전한 키워드를 추천\n*   **마케팅 전략 에이전트**: 판매 데이터 분석, 광고 효율 분석 등을 통해 맞춤형 마케팅 전략을 제안\n*   **대시보드**: 상품 관리, 콘텐츠 관리, 키워드 추천 등 핵심 기능들을 시각적으로 제공\n*   **챗봇**: AI 에이전트와 자연어 기반으로 소통하며, 피드백, 인사이트, 전략 조언 등을 제공\n\n### 1.3. 타겟 사용자\n\n*   1인 스마트스토어 셀러\n*   소규모 이커머스 사업자\n*   부업으로 온라인 판매를 하는 사람\n\n## 2. 기능 상세\n\n### 2.1. 상품 기획 에이전트\n\n*   **트렌드 분석**: 소셜 미디어, 검색 엔진 등에서 트렌드를 분석하여 유망한 상품 아이디어를 발굴\n*   **경쟁사 분석**: 경쟁사의 상품, 판매 전략, 고객 반응 등을 분석하여 차별화된 상품 아이디어를 제안\n*   **데이터 소스**: 소셜 미디어 API, 검색 엔진 API, 경쟁사 웹사이트 크롤링 등\n\n### 2.2. 콘텐츠 생성 에이전트\n\n*   **이미지 생성**: 상품 이미지, 배경 이미지 등을 자동으로 생성 (NanoBanana, generative AI 활용)\n*   **상세 페이지 생성**: 상품 정보, 특징, 장점 등을 활용하여 상세 페이지 자동 생성\n*   **마케팅 문구 생성**: 광고 문구, 홍보 문구 등을 자동으로 생성\n*   **데이터 소스**: 상품 정보, 사용자 리뷰, 경쟁사 상세 페이지 등\n\n### 2.3. 법률 자문 에이전트\n\n*   **상표권 검사**: 상품명, 키워드 등에 대한 상표권 침해 여부 검사\n*   **저작권 검사**: 이미지, 텍스트 등에 대한 저작권 침해 여부 검사\n*   **안전 키워드 추천**: 법적 리스크가 없는 키워드 추천\n*   **데이터 소스**: 특허청 API, 저작권 관련 데이터베이스 등\n\n### 2.4. 마케팅 전략 에이전트\n\n*   **판매 데이터 분석**: 판매량, 매출, 고객 정보 등을 분석하여 마케팅 전략 수립\n*   **광고 효율 분석**: 광고 비용, 노출수, 클릭수 등을 분석하여 광고 효율 개선\n*   **맞춤형 마케팅 전략 제안**: 사용자 데이터, 상품 데이터 등을 기반으로 맞춤형 마케팅 전략 제안\n*   **데이터 소스**: 오픈마켓 API, 광고 플랫폼 API, Google Analytics 등\n\n### 2.5. 대시보드\n\n*   **상품 관리**: 상품 등록, 수정, 삭제 등\n*   **콘텐츠 관리**: 이미지, 상세 페이지, 마케팅 문구 관리\n*   **키워드 추천**: AI 기반 키워드 추천\n*   **판매 현황**: 판매량, 매출, 방문자 수 등\n*   **AI 에이전트 설정**: AI 에이전트의 동작 방식, 파라미터 등을 설정\n\n### 2.6. 챗봇\n\n*   **자연어 기반 소통**: AI 에이전트와 자연어 기반으로 질문하고 답변\n*   **피드백**: AI 에이전트가 생성한 콘텐츠에 대한 피드백 제공\n*   **인사이트**: AI 에이전트가 분석한 데이터에 대한 인사이트 제공\n*   **전략 조언**: AI 에이전트가 제안하는 마케팅 전략에 대한 조언\n\n## 3. UI/UX\n\n*   **톤앤매너**: 신뢰감을 주는 딥 블루 & 깔끔한 화이트, AI를 상징하는 그라데이션 포인트\n*   **레이아웃**: 좌측 사이드바(네비게이션), 중앙 메인 워크스페이스, 우측 AI 채팅/로그 패널\n\n## 4. 기술 스택\n\n*   **프론트엔드**: React\n*   **백엔드**: Node.js\n*   **데이터베이스**: MongoDB\n*   **AI**: OpenAI API, Google Gemini API, NanoBanana API, Langchain, LangGraph\n*   **API**: 스마트스토어 API, 쿠팡 API, 광고 플랫폼 API 등\n\n## 5. 성공 기준\n\n*   **사용자 만족도**: 90% 이상\n*   **업무 자동화율**: 80% 이상\n*   **수익 증대**: 30% 이상\n\n## 6. 개발 로드맵\n\n*   **1단계**: MVP 개발 (대시보드, 상품 관리, 콘텐츠 생성 에이전트)\n*   **2단계**: 법률 자문 에이전트, 마케팅 전략 에이전트 개발\n*   **3단계**: 챗봇 개발, AI 에이전트 성능 개선\n*   **4단계**: 스마트스토어, 쿠팡 등 오픈마켓 연동\n\n## 7. 팀 구성\n\n*   **프로젝트 매니저**: 1명\n*   **프론트엔드 개발자**: 2명\n*   **백엔드 개발자**: 2명\n*   **AI 개발자**: 2명\n*   **디자이너**: 1명\n\n## 8. 예산\n\n*   **총 예산**: 1억원\n*   **인건비**: 7000만원\n*   **API 사용료**: 1000만원\n*   **서버 비용**: 1000만원\n*   **마케팅 비용**: 1000만원",
      "writedAt": "2025-12-05T09:49:00.638Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **Project Overview**: AI 에이전트를 활용한 1인 셀러 지원 SaaS 플랫폼 개발. 상품 기획부터 고객 관리까지 자동화하여 브랜딩 집중 환경 제공.\n- **Core Technology Stack**: Python (FastAPI), React (Next.js), MongoDB, Pinecone/Weaviate, TensorFlow Serving/TorchServe, Google 로그인, 토스 결제 API, Cursor, Next.js(easynext), Supabase MCP, Vercel.\n- **Key Technical Objectives**: 높은 사용자 만족도 (90% 이상), 높은 업무 자동화율 (80% 이상), 수익 증대 (30% 이상), 확장 가능한 아키텍처, 안정적인 서비스 운영.\n- **Critical Technical Assumptions**: OpenAI API, Google Gemini API, NanoBanana API, Langchain, LangGraph 등 외부 AI API의 안정적인 가용성, 스마트스토어, 쿠팡 등 오픈마켓 API의 접근성 및 데이터 정확성.\n\n## 2. Tech Stack\n\n| Category          | Technology / Library        | Reasoning (Why it's chosen for this project) |\n| ----------------- | --------------------------- | -------------------------------------------- |\n| Backend           | Python, FastAPI             | 빠른 개발 속도, 비동기 처리, AI/ML 라이브러리 호환성, API 구축 용이성. |\n| Frontend          | React, Next.js(easynext)    | 컴포넌트 기반 UI 개발, 풍부한 생태계, SEO 최적화, 서버 사이드 렌더링 지원. |\n| Database          | MongoDB                     | 유연한 스키마, NoSQL 특성으로 다양한 데이터 형태 저장에 용이, JSON 기반 데이터 처리. |\n| Vector DB         | Pinecone / Weaviate        | 대규모 벡터 데이터 저장 및 검색에 최적화, AI 에이전트의 데이터 검색 성능 향상. |\n| Model Serving     | TensorFlow Serving / TorchServe | 머신러닝 모델 배포 및 관리, 실시간 추론 서비스 제공. |\n| Authentication    | Google 로그인               | 간편한 사용자 인증, 널리 사용되는 표준 프로토콜 지원. |\n| Payment           | 토스 결제 API               | 간편하고 안전한 결제 기능 제공, 다양한 결제 수단 지원. |\n| Code Editor       | Cursor                      | AI 기반 코딩 지원, 생산성 향상. |\n| MCP               | Supabase                    | 인증, 데이터베이스, 스토리지 등 백엔드 기능 통합 제공, 빠른 개발 및 배포 지원. |\n| Hosting           | Vercel                      | 프론트엔드 배포에 최적화, 자동 스케일링, CDN 지원. |\n| AI Framework      | Langchain, LangGraph        | LLM 기반 애플리케이션 개발 프레임워크, 다양한 LLM 모델 연동 지원. |\n| Image Generation  | NanoBanana API              | 이미지 생성 기능 제공, 콘텐츠 생성 에이전트 활용. |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- **Frontend (Next.js)**: 사용자 인터페이스 및 사용자 상호 작용 처리.\n    - 하위 구성 요소: 대시보드 컴포넌트, 상품 관리 컴포넌트, 콘텐츠 관리 컴포넌트, 챗봇 UI 컴포넌트.\n- **Backend (FastAPI)**: API 엔드포인트 제공, 비즈니스 로직 처리, 데이터베이스 연동.\n    - 하위 구성 요소: 상품 기획 API, 콘텐츠 생성 API, 법률 자문 API, 마케팅 전략 API, 사용자 인증 API, 결제 API.\n- **Database (MongoDB)**: 상품 정보, 사용자 정보, 판매 데이터, AI 에이전트 데이터 저장.\n    - 하위 구성 요소: 상품 컬렉션, 사용자 컬렉션, 판매 컬렉션, 키워드 컬렉션.\n- **AI Agents**: 상품 기획, 콘텐츠 생성, 법률 자문, 마케팅 전략 에이전트.\n    - 하위 구성 요소: 트렌드 분석 모듈, 경쟁사 분석 모듈, 이미지 생성 모듈, 상세 페이지 생성 모듈, 상표권 검사 모듈, 판매 데이터 분석 모듈.\n- **Vector Database (Pinecone/Weaviate)**: 임베딩된 상품 정보, 사용자 리뷰, 마케팅 자료 저장 및 검색.\n    - 하위 구성 요소: 상품 벡터 인덱스, 리뷰 벡터 인덱스, 마케팅 자료 벡터 인덱스.\n- **Model Serving (TensorFlow Serving/TorchServe)**: 머신러닝 모델 배포 및 관리.\n    - 하위 구성 요소: 상품 추천 모델, 마케팅 전략 모델.\n\n### Top-Level Component Interaction Diagram\n\n```mermaid\ngraph LR\n    A[Frontend (Next.js)] --> B[Backend (FastAPI)]\n    B --> C[Database (MongoDB)]\n    B --> D[AI Agents]\n    D --> E[Vector Database (Pinecone/Weaviate)]\n    D --> F[Model Serving (TensorFlow Serving/TorchServe)]\n    A --> G[Google 로그인]\n    B --> H[토스 결제 API]\n```\n\n- **Frontend (Next.js) <-> Backend (FastAPI)**: 사용자 요청을 API 엔드포인트를 통해 백엔드로 전달하고, 백엔드는 처리 결과를 프론트엔드로 반환합니다.\n- **Backend (FastAPI) <-> Database (MongoDB)**: 백엔드는 데이터베이스에 데이터를 저장하고 검색하여 필요한 정보를 관리합니다.\n- **Backend (FastAPI) <-> AI Agents**: 백엔드는 AI 에이전트에게 요청을 전달하고, 에이전트는 분석 및 생성된 결과를 백엔드로 반환합니다.\n- **AI Agents <-> Vector Database (Pinecone/Weaviate) / Model Serving (TensorFlow Serving/TorchServe)**: AI 에이전트는 벡터 데이터베이스에서 정보를 검색하거나 머신러닝 모델을 사용하여 분석 및 예측을 수행합니다.\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **Domain Separation**: 사용자 관리, 상품 관리, 콘텐츠 생성, 마케팅 전략, 법률 자문 등으로 도메인 분리.\n- **Layer-Based Architecture**: 프레젠테이션 레이어 (Next.js 컴포넌트), 비즈니스 로직 레이어 (FastAPI API 핸들러), 데이터 접근 레이어 (MongoDB 쿼리).\n- **Feature-Based Modules**: 각 기능별 폴더 (예: 상품 기획, 콘텐츠 생성)에 관련된 파일들을 모아 관리.\n- **Shared Components**: 공통 유틸리티 함수, 타입 정의, 재사용 가능한 컴포넌트를 별도 모듈로 관리.\n\n**Universal File & Folder Structure**\n```\n/\n├── frontend/                 # Next.js 프론트엔드 코드\n│   ├── components/          # 재사용 가능한 UI 컴포넌트\n│   │   ├── Dashboard/       # 대시보드 관련 컴포넌트\n│   │   ├── Product/         # 상품 관련 컴포넌트\n│   │   └── ...\n│   ├── pages/               # Next.js 페이지\n│   │   ├── index.js         # 메인 페이지\n│   │   └── ...\n│   ├── styles/              # CSS 스타일\n│   └── utils/               # 유틸리티 함수\n├── backend/                  # FastAPI 백엔드 코드\n│   ├── app/                # FastAPI 애플리케이션\n│   │   ├── api/             # API 엔드포인트\n│   │   │   ├── product.py   # 상품 관련 API\n│   │   │   ├── content.py   # 콘텐츠 관련 API\n│   │   │   └── ...\n│   │   ├── core/            # 핵심 로직\n│   │   ├── db/              # 데이터베이스 관련\n│   │   ├── models/          # 데이터 모델\n│   │   └── utils/           # 유틸리티 함수\n│   ├── main.py             # FastAPI 애플리케이션 시작점\n│   └── requirements.txt    # Python 의존성\n├── ai_agents/              # AI 에이전트 코드\n│   ├── product_planning/   # 상품 기획 에이전트\n│   ├── content_generation/ # 콘텐츠 생성 에이전트\n│   └── ...\n├── docker-compose.yml      # Docker Compose 설정 파일\n└── README.md\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: 프론트엔드는 API 요청을 백엔드로 보내고, 백엔드는 JSON 형식으로 응답합니다.\n- **Database Interaction**: MongoDB 드라이버를 사용하여 데이터베이스에 연결하고, 쿼리 및 업데이트를 수행합니다.\n- **External Service Integration**: OpenAI API, Google Gemini API, NanoBanana API 등 외부 API를 사용하여 데이터를 가져오고, 결과를 처리합니다.\n- **Data Synchronization**: 데이터 변경 시 이벤트 기반 아키텍처를 사용하여 다른 컴포넌트에 알립니다.\n\n## 4. Performance & Optimization Strategy\n- **데이터베이스 쿼리 최적화**: 인덱싱, 쿼리 프로파일링을 통해 데이터베이스 쿼리 성능을 개선합니다.\n- **캐싱**: 자주 사용되는 데이터는 Redis 또는 Memcached를 사용하여 캐싱합니다.\n- **비동기 처리**: I/O 바운드 작업은 Celery 또는 asyncio를 사용하여 비동기적으로 처리합니다.\n- **코드 프로파일링**: 성능 병목 지점을 파악하고 코드를 최적화합니다.\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: FastAPI 백엔드, Next.js 프론트엔드, MongoDB 데이터베이스 설정.\n- **Essential Features**: 대시보드, 상품 관리, 콘텐츠 생성 에이전트 (기본 기능).\n- **Basic Security**: 사용자 인증 및 권한 관리, API 보안.\n- **Development Setup**: 개발 환경 구축, CI/CD 파이프라인 설정 (GitHub Actions, Vercel).\n- **Timeline**: 3개월\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: 법률 자문 에이전트, 마케팅 전략 에이전트 개발.\n- **Performance Optimization**: 데이터베이스 쿼리 최적화, 캐싱, 비동기 처리.\n- **Enhanced Security**: 보안 취약점 분석 및 패치, 데이터 암호화.\n- **Monitoring Implementation**: Prometheus, Grafana를 사용하여 시스템 모니터링 환경 구축.\n- **Timeline**: 3개월\n\n### Phase 3: AI & Integration\n- **AI Enhancement**: 챗봇 개발, AI 에이전트 성능 개선 (모델 재학습, 파라미터 튜닝).\n- **Integration**: 스마트스토어, 쿠팡 등 오픈마켓 연동.\n- **Timeline**: 3개월\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **Technology Risks**: AI API의 불안정성, 데이터 정확성 문제.\n    - **Mitigation Strategies**: 여러 API 제공업체 (OpenAI, Google Gemini)를 사용하여 API 장애에 대비, 데이터 검증 로직 강화.\n- **Performance Risks**: 대규모 데이터 처리 및 AI 모델 추론 시 성능 저하.\n    - **Mitigation Strategies**: 데이터베이스 쿼리 최적화, 캐싱, 비동기 처리, 모델 경량화.\n- **Security Risks**: 사용자 데이터 유출, API 공격.\n    - **Mitigation Strategies**: 보안 취약점 분석 및 패치, 데이터 암호화, API 인증 강화.\n- **Integration Risks**: 오픈마켓 API 변경, 호환성 문제.\n    - **Mitigation Strategies**: API 변경 사항 모니터링, 호환성 테스트, 어댑터 패턴 적용.\n\n### Project Delivery Risks\n- **Timeline Risks**: 개발 지연, 일정 압박.\n    - **Contingency Plans**: 스프린트 주기 단축, 기능 우선순위 조정, 추가 인력 투입.\n- **Resource Risks**: 개발자 부족, 기술 역량 부족.\n    - **Contingency Plans**: 추가 채용, 외부 전문가 활용, 기술 교육.\n- **Quality Risks**: 코드 품질 저하, 버그 발생.\n    - **Contingency Plans**: 코드 리뷰 강화, 자동화 테스트 확대, 버그 수정 우선순위 조정.\n- **Deployment Risks**: 배포 실패, 시스템 장애.\n    - **Contingency Plans**: 배포 전 테스트 환경에서 충분한 테스트, 롤백 전략 마련.\n",
      "writedAt": "2025-12-05T09:49:00.639Z"
    },
    {
      "type": "guideline",
      "content": "```markdown\n# AI Seller SaaS Platform - Code Guidelines\n\n## 1. Project Overview\n\nThis project develops a SaaS platform using AI agents to automate tasks for solo e-commerce sellers. Key architectural decisions include a React-based frontend (Next.js), a Python (FastAPI) backend, MongoDB for data storage, and Langchain/LangGraph for AI agent orchestration. Vector databases (Pinecone/Weaviate) are used for semantic search, and TensorFlow Serving/TorchServe for model deployment.\n\n## 2. Core Principles\n\n*   **Maintainability**: Code should be easy to understand, modify, and debug by any team member.\n*   **Testability**: Code should be written in a way that allows for easy unit and integration testing.\n*   **Performance**: Code should be optimized for speed and efficiency.\n*   **Readability**: Code should be clear, concise, and well-documented.\n*   **Security**: Code should be written with security best practices in mind to prevent vulnerabilities.\n\n## 3. Language-Specific Guidelines\n\n### 3.1. Python (FastAPI)\n\n#### File Organization and Directory Structure\n\n*   Follow the Domain-Driven Design (DDD) principles.\n*   Use a clear and consistent directory structure. Example:\n\n    ```\n    backend/\n    ├── app/\n    │   ├── api/             # API endpoints (routers)\n    │   │   ├── product.py   # Product-related APIs\n    │   │   ├── content.py   # Content-related APIs\n    │   │   └── ...\n    │   ├── core/            # Core application logic\n    │   ├── db/              # Database connection and models\n    │   ├── models/          # Data models (Pydantic)\n    │   ├── schemas/         # Request/Response schemas (Pydantic)\n    │   ├── services/        # Business logic services\n    │   ├── utils/           # Utility functions\n    │   └── __init__.py\n    ├── main.py             # FastAPI application entry point\n    └── requirements.txt    # Dependencies\n    ```\n\n#### Import/Dependency Management\n\n*   Use `poetry` or `pip` for dependency management.\n*   Specify dependencies in `pyproject.toml` (for Poetry) or `requirements.txt` (for pip).\n*   Use explicit imports: `from module import function` instead of `import module`.\n*   Group imports by standard library, third-party libraries, and local modules.\n\n    ```python\n    # Standard library imports\n    import os\n    import json\n\n    # Third-party library imports\n    from fastapi import FastAPI, HTTPException\n    from pymongo import MongoClient\n\n    # Local module imports\n    from app.models import Product\n    ```\n\n#### Error Handling Patterns\n\n*   Use `try...except` blocks for handling exceptions.\n*   Raise custom exceptions for specific error conditions.\n*   Use FastAPI's `HTTPException` for returning HTTP error responses.\n*   Log errors with sufficient context for debugging.\n\n    ```python\n    from fastapi import FastAPI, HTTPException\n    import logging\n\n    logger = logging.getLogger(__name__)\n\n    async def get_product(product_id: str):\n        try:\n            product = await db.find_one({\"_id\": product_id})\n            if not product:\n                raise HTTPException(status_code=404, detail=\"Product not found\")\n            return product\n        except Exception as e:\n            logger.exception(f\"Error getting product {product_id}: {e}\")\n            raise HTTPException(status_code=500, detail=\"Internal server error\")\n    ```\n\n### 3.2. React (Next.js)\n\n#### File Organization and Directory Structure\n\n*   Use the Next.js `app` directory structure.\n*   Organize components into logical directories.\n*   Separate UI components from business logic.\n\n    ```\n    frontend/\n    ├── app/\n    │   ├── dashboard/\n    │   │   ├── page.tsx       # Dashboard page component\n    │   │   └── components/   # Dashboard-specific components\n    │   ├── products/\n    │   │   ├── page.tsx       # Product page component\n    │   │   └── components/   # Product-specific components\n    │   ├── api/             # API route handlers\n    │   │   ├── products/\n    │   │   │   └── route.ts   # API route for products\n    │   └── ...\n    ├── components/          # Reusable UI components\n    ├── utils/               # Utility functions\n    ├── styles/              # Global styles\n    └── ...\n    ```\n\n#### Import/Dependency Management\n\n*   Use `npm` or `yarn` for dependency management.\n*   Declare dependencies in `package.json`.\n*   Use absolute imports for components and modules.\n\n    ```javascript\n    // Correct: Absolute import\n    import ProductCard from '@/components/ProductCard';\n\n    // Incorrect: Relative import (avoid)\n    import ProductCard from '../../components/ProductCard';\n    ```\n\n#### Error Handling Patterns\n\n*   Use `try...catch` blocks for handling errors.\n*   Display user-friendly error messages.\n*   Log errors to the console or a logging service.\n*   Consider using error boundary components to prevent crashes.\n\n    ```javascript\n    import { useState, useEffect } from 'react';\n\n    function ProductList() {\n      const [products, setProducts] = useState([]);\n      const [error, setError] = useState(null);\n\n      useEffect(() => {\n        async function fetchProducts() {\n          try {\n            const response = await fetch('/api/products');\n            if (!response.ok) {\n              throw new Error('Failed to fetch products');\n            }\n            const data = await response.json();\n            setProducts(data);\n          } catch (err) {\n            console.error(\"Error fetching products:\", err);\n            setError(err.message);\n          }\n        }\n        fetchProducts();\n      }, []);\n\n      if (error) {\n        return <div>Error: {error}</div>;\n      }\n\n      return (\n        <ul>\n          {products.map(product => (\n            <li key={product.id}>{product.name}</li>\n          ))}\n        </ul>\n      );\n    }\n    ```\n\n## 4. Code Style Rules\n\n#### MUST Follow:\n\n*   **Naming Conventions**:\n    *   Python: `snake_case` for variables and functions, `PascalCase` for classes.\n    *   JavaScript/TypeScript: `camelCase` for variables and functions, `PascalCase` for components.\n    *   Consistent naming across the project.\n    *   Rationale: Ensures consistency and readability.\n*   **Code Formatting**:\n    *   Python: Use `black` and `flake8` for code formatting and linting.\n    *   JavaScript/TypeScript: Use `eslint` and `prettier` for code formatting and linting.\n    *   Rationale: Enforces a consistent code style and prevents common errors.\n*   **Comments and Documentation**:\n    *   Write clear and concise comments to explain complex logic.\n    *   Document all functions and classes with docstrings (Python) or JSDoc (JavaScript/TypeScript).\n    *   Rationale: Improves code understanding and maintainability.\n*   **Testing**:\n    *   Write unit tests for all core functions and components.\n    *   Use integration tests to verify the interaction between different parts of the system.\n    *   Rationale: Ensures code correctness and prevents regressions.\n*   **Security Best Practices**:\n    *   Sanitize user inputs to prevent XSS and SQL injection attacks.\n    *   Use secure authentication and authorization mechanisms.\n    *   Rationale: Protects the system from security vulnerabilities.\n*   **Use Environment Variables**:\n    *   Store sensitive information like API keys and database credentials in environment variables.\n    *   Rationale: Avoids hardcoding sensitive data in the codebase.\n\n#### MUST NOT Do:\n\n*   **Global Variables**:\n    *   Avoid using global variables. Use dependency injection or state management solutions instead.\n    *   Rationale: Global variables can lead to unpredictable behavior and make code harder to test.\n*   **Magic Numbers/Strings**:\n    *   Avoid using hardcoded numbers or strings directly in the code. Use constants instead.\n    *   Rationale: Improves code readability and maintainability.\n*   **Nested Callbacks**:\n    *   Avoid deeply nested callbacks. Use promises, async/await, or reactive programming techniques instead.\n    *   Rationale: Makes code harder to read and debug (Callback Hell).\n*   **Ignoring Errors**:\n    *   Never ignore errors. Handle errors gracefully and log them appropriately.\n    *   Rationale: Ignoring errors can lead to unexpected behavior and make it difficult to debug problems.\n*   **Over-commenting**:\n    *   Comments should explain the *why* and not the *what*. Code should be self-explanatory where possible.\n    *   Rationale: Too many comments clutter the code and make it harder to read.\n*   **Committing Secrets**:\n    *   Never commit sensitive information (API keys, passwords) to the repository.\n    *   Rationale: Prevents security breaches.\n\n## 5. Architecture Patterns\n\n### Component/Module Structure Guidelines\n\n*   **Frontend (React/Next.js)**:\n    *   Use functional components with hooks for state management and side effects.\n    *   Separate components into presentational and container components.\n    *   Use a component library (e.g., Material UI, Ant Design) for consistent UI elements.\n*   **Backend (FastAPI)**:\n    *   Use dependency injection to manage dependencies.\n    *   Separate concerns into different modules (e.g., API endpoints, business logic, data access).\n    *   Use Pydantic models for data validation and serialization.\n\n### Data Flow Patterns\n\n*   **Frontend to Backend**:\n    *   Use `fetch` or `axios` to make API requests to the backend.\n    *   Handle API responses and errors appropriately.\n*   **Backend to Database**:\n    *   Use a database driver (e.g., `pymongo`) to interact with the MongoDB database.\n    *   Use asynchronous operations to prevent blocking the main thread.\n*   **AI Agent Interaction**:\n    *   Backend orchestrates calls to the AI agents (Langchain/LangGraph).\n    *   AI agents interact with Vector DBs (Pinecone/Weaviate) to retrieve relevant information.\n\n### State Management Conventions\n\n*   **Frontend (React/Next.js)**:\n    *   Use React Context for global state management.\n    *   Consider using a state management library like Zustand or Redux for complex state management needs.\n    *   Use server actions for mutations and data fetching.\n\n### API Design Standards\n\n*   **RESTful APIs**:\n    *   Follow RESTful principles for API design.\n    *   Use standard HTTP methods (GET, POST, PUT, DELETE).\n    *   Use meaningful resource names (e.g., `/products`, `/users`).\n*   **JSON Format**:\n    *   Use JSON for request and response bodies.\n*   **Error Handling**:\n    *   Return appropriate HTTP status codes for errors.\n    *   Include error messages in the response body.\n*   **Authentication**:\n    *   Use JWT (JSON Web Tokens) for authentication.\n    *   Implement proper authorization mechanisms.\n*   **Versioning**:\n    *   Versioning the API using URL path (e.g., `/api/v1/products`).\n\n```python\n# MUST: Example of a well-defined API endpoint in FastAPI\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom typing import List\nfrom app.models import Product\nfrom app.schemas import ProductCreate, ProductRead\nfrom app.services import product_service\n\nrouter = APIRouter()\n\n@router.post(\"/\", response_model=ProductRead, status_code=201)\nasync def create_product(product_create: ProductCreate, service: product_service = Depends()):\n    \"\"\"\n    Endpoint to create a new product.\n    \"\"\"\n    return await service.create_product(product_create)\n\n@router.get(\"/{product_id}\", response_model=ProductRead)\nasync def get_product(product_id: str, service: product_service = Depends()):\n    \"\"\"\n    Endpoint to retrieve a product by its ID.\n    \"\"\"\n    product = await service.get_product(product_id)\n    if not product:\n        raise HTTPException(status_code=404, detail=\"Product not found\")\n    return product\n\n# Explanation:\n# - Uses FastAPI's APIRouter for modular API definition.\n# - Includes type hints for request and response models (Pydantic).\n# - Uses dependency injection for service layer.\n# - Handles errors with HTTPException.\n# - Provides docstrings for API documentation.\n```\n\n```python\n# MUST NOT: Example of a poorly designed API endpoint (FastAPI)\n\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/getData\")\nasync def get_data(param1, param2, param3): # No type hints, unclear what parameters are\n    # Complex logic directly in the endpoint\n    result = do_something_complex(param1, param2, param3)\n    return {\"result\": result}\n\n# Explanation:\n# - Lacks type hints, making it difficult to understand the expected data types.\n# - Contains complex logic directly within the endpoint, making it hard to test and maintain.\n# - Does not follow RESTful principles.\n```\n\n```javascript\n// MUST: React component example with proper structure\nimport React, { useState, useEffect } from 'react';\nimport { Product } from '@/types/product'; //Using absolute import\nimport { getProducts } from '@/api/products';    //Using absolute import\n\ninterface ProductListProps {\n  // Props definition if any\n}\n\nconst ProductList: React.FC<ProductListProps> = () => {\n  const [products, setProducts] = useState<Product[]>([]);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const fetchProducts = async () => {\n      try {\n        const data = await getProducts();\n        setProducts(data);\n      } catch (e: any) {\n        setError(e.message);\n        console.error(\"Failed to fetch products\", e);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchProducts();\n  }, []);\n\n  if (isLoading) {\n    return <div>Loading products...</div>;\n  }\n\n  if (error) {\n    return <div>Error: {error}</div>;\n  }\n\n  return (\n    <ul>\n      {products.map((product) => (\n        <li key={product.id}>{product.name}</li>\n      ))}\n    </ul>\n  );\n};\n\nexport default ProductList;\n\n//Explanation:\n// - Using types for state variables\n// - Separated data fetching logic into `api/products.ts`\n// - Clear loading and error states\n```\n\n```javascript\n// MUST NOT: React component example to avoid\n\nimport React, { useState, useEffect } from 'react';\n\nconst ProductList = () => {\n  const [data, setData] = useState([]);\n\n  useEffect(() => {\n    fetch('/api/products')\n      .then((res) => res.json())\n      .then((data) => setData(data))\n      .catch((err) => console.error(err));\n  }, []);\n\n  return ( //No error handling, No types, inline fetch, no loading state\n    <ul>\n      {data.map((item) => (\n        <li key={item.id}>{item.name}</li>\n      ))}\n    </ul>\n  );\n};\n\nexport default ProductList;\n\n//Explanation:\n// - No error handling\n// - No loading state\n// - Inline fetch logic\n// - Missing types\n```\n",
      "writedAt": "2025-12-05T09:49:00.639Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-12-05T09:49:00.639Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-12-05T09:49:00.639Z"
    }
  ]
}